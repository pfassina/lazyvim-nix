{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.programs.lazyvim;
  
  # Load plugin data and mappings
  pluginData = pkgs.lazyvimPluginData or (builtins.fromJSON (builtins.readFile ./plugins.json));
  pluginMappings = pkgs.lazyvimPluginMappings or (import ./plugin-mappings.nix);
  pluginOverrides = pkgs.lazyvimOverrides or (import ./overrides/default.nix { inherit pkgs; });
  
  # Helper function to resolve plugin names
  resolvePluginName = lazyName:
    let
      mapping = pluginMappings.${lazyName} or null;
    in
      if mapping == null then
        # Try automatic resolution
        let
          parts = lib.splitString "/" lazyName;
          repoName = if length parts == 2 then elemAt parts 1 else lazyName;
          # Convert repo-name to repo_name and repo.nvim to repo-nvim
          nixName = lib.replaceStrings ["-" "."] ["_" "-"] repoName;
        in nixName
      else if builtins.isString mapping then
        mapping
      else
        mapping.package;
  
  # Helper function to detect multi-module plugins
  detectMultiModulePlugins = pluginSpecs:
    let
      isMultiModulePlugin = pluginSpec:
        let
          mapping = pluginMappings.${pluginSpec.name} or null;
        in
          mapping != null && builtins.isAttrs mapping && mapping ? module;
    in
      filter isMultiModulePlugin pluginSpecs;
  
  # Helper function to expand multi-module plugins into individual entries
  expandMultiModulePlugins = pluginSpecs:
    let
      multiModulePlugins = detectMultiModulePlugins pluginSpecs;
      regularPlugins = filter (spec: 
        let
          mapping = pluginMappings.${spec.name} or null;
        in
          mapping == null || builtins.isString mapping || !(mapping ? module)
      ) pluginSpecs;
      
      # Create individual entries for multi-module plugins
      expandedEntries = map (pluginSpec:
        let
          mapping = pluginMappings.${pluginSpec.name};
          nixName = resolvePluginName pluginSpec.name;
          plugin = pkgs.vimPlugins.${nixName} or null;
        in
          if plugin == null then
            null
          else
            {
              name = mapping.module;  # Use module name for LazyVim to find
              nixName = nixName;
              plugin = plugin;
              originalSpec = pluginSpec;
            }
      ) multiModulePlugins;
    in
      {
        regular = regularPlugins;
        expanded = filter (entry: entry != null) expandedEntries;
      };

  # Helper function to create dev path with proper symlinks for all plugins
  createDevPath = allPluginSpecs: allResolvedPlugins:
    let
      # Extract repository name from plugin spec (e.g., "owner/repo.nvim" -> "repo.nvim")
      getRepoName = specName:
        let parts = lib.splitString "/" specName;
        in if length parts == 2 then elemAt parts 1 else specName;
      
      # Create symlinks using the repository names that LazyVim expects
      mainLinks = lib.zipListsWith (spec: plugin:
        if plugin != null then
          let repoName = getRepoName spec.name;
          in "ln -sf ${plugin} $out/${repoName}"
        else
          null
      ) allPluginSpecs allResolvedPlugins;
      
      # Filter out null entries
      validLinks = filter (link: link != null) mainLinks;
    in
      pkgs.runCommand "lazyvim-dev-path" {} ''
        mkdir -p $out
        ${lib.concatStringsSep "\n" validLinks}
      '';

  # Expand multi-module plugins and separate regular plugins
  pluginSeparation = expandMultiModulePlugins (pluginData.plugins or []);
  
  # Build the list of all plugins from plugins.json
  allPluginSpecs = pluginData.plugins or [];
  
  # Resolve all plugins to their nixpkgs equivalents
  resolvedPlugins = map (pluginSpec:
    let
      nixName = resolvePluginName pluginSpec.name;
      plugin = pkgs.vimPlugins.${nixName} or null;
    in
      if plugin == null then
        builtins.trace "Warning: Could not find plugin ${pluginSpec.name} (tried ${nixName})" null
      else
        plugin
  ) allPluginSpecs;
  
  # Create the dev path with proper symlinks
  devPath = createDevPath allPluginSpecs resolvedPlugins;
  
  # Extract repository name from plugin spec (needed for config generation)
  getRepoName = specName:
    let parts = lib.splitString "/" specName;
    in if length parts == 2 then elemAt parts 1 else specName;
  
  # Generate dev plugin specs for available plugins
  devPluginSpecs = lib.zipListsWith (spec: plugin:
    if plugin != null then
      ''{ "${getRepoName spec.name}", dev = true },''
    else
      null
  ) allPluginSpecs resolvedPlugins;
  
  # Filter out null entries
  availableDevSpecs = filter (s: s != null) devPluginSpecs;
  
  # Generate lazy.nvim configuration
  lazyConfig = ''
    -- LazyVim Nix Configuration
    -- This file is auto-generated by the lazyvim-nix flake
    
    local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
    if not vim.loop.fs_stat(lazypath) then
      vim.fn.system({
        "git",
        "clone",
        "--filter=blob:none",
        "https://github.com/folke/lazy.nvim.git",
        "--branch=stable",
        lazypath,
      })
    end
    vim.opt.rtp:prepend(lazypath)
    
    -- Configure lazy.nvim to use pre-fetched plugins
    require("lazy").setup({
      defaults = { lazy = true },
      dev = {
        path = "${devPath}",
        patterns = {},  -- Don't automatically match, use explicit dev = true
        fallback = false,
      },
      spec = {
        { "LazyVim/LazyVim", import = "lazyvim.plugins", dev = true },
        -- Disable Mason.nvim in Nix environment
        { "williamboman/mason.nvim", enabled = false },
        { "williamboman/mason-lspconfig.nvim", enabled = false },
        { "jay-babu/mason-nvim-dap.nvim", enabled = false },
        -- Disable treesitter auto-install - simple approach like your old config
        { 
          "nvim-treesitter/nvim-treesitter", 
          opts = function(_, opts)
            opts.ensure_installed = {}
          end,
          dev = true,
        },
        -- Mark available plugins as dev = true
        ${concatStringsSep "\n        " availableDevSpecs}
        -- User plugins
        { import = "plugins" },
      },
      performance = {
        rtp = {
          disabled_plugins = {
            "gzip",
            "matchit",
            "matchparen",
            "netrwPlugin",
            "tarPlugin",
            "tohtml",
            "tutor",
            "zipPlugin",
          },
        },
      },
    })
    
  '';
  
  # Treesitter configuration - using packages directly
  treesitterGrammars = let
    parsers = pkgs.symlinkJoin {
      name = "treesitter-parsers";
      paths = (pkgs.vimPlugins.nvim-treesitter.withPlugins (_: cfg.treesitterParsers)).dependencies;
    };
  in parsers;

in {
  options.programs.lazyvim = {
    enable = mkEnableOption "LazyVim - A Neovim configuration framework";
    
    extraPackages = mkOption {
      type = types.listOf types.package;
      default = [];
      example = literalExpression ''
        with pkgs; [
          rust-analyzer
          gopls
          nodePackages.typescript-language-server
        ]
      '';
      description = ''
        Additional packages to be made available to LazyVim.
        This should include LSP servers, formatters, linters, and other tools.
      '';
    };
    
    treesitterParsers = mkOption {
      type = types.listOf types.package;
      default = with pkgs.tree-sitter-grammars; [ 
        tree-sitter-lua 
        tree-sitter-vim 
        tree-sitter-vimdoc 
        tree-sitter-query 
        tree-sitter-markdown 
        tree-sitter-markdown-inline 
      ];
      example = literalExpression ''
        with pkgs.tree-sitter-grammars; [
          tree-sitter-rust
          tree-sitter-go
          tree-sitter-typescript
          tree-sitter-tsx
          tree-sitter-python
        ]
      '';
      description = ''
        List of Treesitter parser packages to install.
        These should be packages from pkgs.tree-sitter-grammars.
      '';
    };
    
    
    config = mkOption {
      type = types.submodule {
        options = {
          autocmds = mkOption {
            type = types.str;
            default = "";
            example = ''
              -- Auto-save on focus loss
              vim.api.nvim_create_autocmd("FocusLost", {
                command = "silent! wa",
              })
            '';
            description = ''
              Lua code for autocmds that will be written to lua/config/autocmds.lua.
              This file is loaded by LazyVim for user autocmd configurations.
            '';
          };
          
          keymaps = mkOption {
            type = types.str;
            default = "";
            example = ''
              -- Custom keymaps
              vim.keymap.set("n", "<leader>w", "<cmd>w<cr>", { desc = "Save file" })
              vim.keymap.set("n", "<C-h>", "<cmd>TmuxNavigateLeft<cr>", { desc = "Go to left window" })
            '';
            description = ''
              Lua code for keymaps that will be written to lua/config/keymaps.lua.
              This file is loaded by LazyVim for user keymap configurations.
            '';
          };
          
          options = mkOption {
            type = types.str;
            default = "";
            example = ''
              -- Custom vim options
              vim.opt.relativenumber = false
              vim.opt.wrap = true
              vim.opt.conceallevel = 0
            '';
            description = ''
              Lua code for vim options that will be written to lua/config/options.lua.
              This file is loaded by LazyVim for user option configurations.
            '';
          };
        };
      };
      default = {};
      description = ''
        LazyVim configuration files. These map to the lua/config/ directory structure
        and are loaded by LazyVim automatically.
      '';
    };
    
    plugins = mkOption {
      type = types.attrsOf types.str;
      default = {};
      example = literalExpression ''
        {
          custom-theme = '''
            return {
              "folke/tokyonight.nvim",
              opts = {
                style = "night",
                transparent = true,
              },
            }
          ''';
          
          lsp-config = '''
            return {
              "neovim/nvim-lspconfig",
              opts = function(_, opts)
                opts.servers.rust_analyzer = {
                  settings = {
                    ["rust-analyzer"] = {
                      checkOnSave = {
                        command = "clippy",
                      },
                    },
                  },
                }
              end,
            }
          ''';
        }
      '';
      description = ''
        Plugin configuration files. Each key becomes a file lua/plugins/{key}.lua 
        with the corresponding Lua code. These files are automatically loaded by LazyVim.
      '';
    };
  };
  
  config = mkIf cfg.enable {
    # Ensure neovim is enabled
    programs.neovim = {
      enable = true;
      package = pkgs.neovim-unwrapped;
            
      withNodeJs = true;
      withPython3 = true;
      withRuby = false;
      
      # Add all required packages
      extraPackages = cfg.extraPackages ++ (with pkgs; [
        # Required by LazyVim
        git
        ripgrep
        fd
        
        # Language servers and tools can be added by the user
      ]);
      
      # Add lazy.nvim as a plugin
      plugins = [ pkgs.vimPlugins.lazy-nvim ];
    };
    
    # Create LazyVim configuration
    xdg.configFile = {
      "nvim/init.lua".text = lazyConfig;
      
      # Link treesitter parsers - exact same approach as your old config
      "nvim/parser".source = "${treesitterGrammars}/parser";
      
      # LazyVim config files
      "nvim/lua/config/autocmds.lua" = mkIf (cfg.config.autocmds != "") {
        text = ''
          -- User autocmds configured via Nix
          ${cfg.config.autocmds}
        '';
      };
      
      "nvim/lua/config/keymaps.lua" = mkIf (cfg.config.keymaps != "") {
        text = ''
          -- User keymaps configured via Nix
          ${cfg.config.keymaps}
        '';
      };
      
      "nvim/lua/config/options.lua" = mkIf (cfg.config.options != "") {
        text = ''
          -- User options configured via Nix
          ${cfg.config.options}
        '';
      };
      
    } 
    # Generate plugin configuration files
    // (lib.mapAttrs' (name: content: 
      lib.nameValuePair "nvim/lua/plugins/${name}.lua" {
        text = ''
          -- Plugin configuration for ${name} (configured via Nix)
          ${content}
        '';
      }
    ) cfg.plugins);
  };
}
